/* eslint-disable import/no-default-export -- cobalt plugins do this */

// @ts-check

import { defaultTransformer, serializeJS } from '@cobalt-ui/plugin-js';
import { set } from '@cobalt-ui/utils';
import ts from 'typescript';

/**
 * @param {{ filename: string; }} options
 * @returns {import('@cobalt-ui/core').Plugin}
 */
export default function pluginTS(options) {
	return {
		name: 'plugin-ts',
		// eslint-disable-next-line @typescript-eslint/no-empty-function -- it needs to be present
		config(/* config */) {},
		async build({ tokens /* metadata, rawSchema */ }) {
			const header = `/**
* Design Tokens
* Autogenerated from tokens.json.
* DO NOT EDIT!
*/

`;
			// this is where we'll store the transformed tokens
			/** @type {Object.<string, string>} */
			const transformedTokens = {};

			/** @type {Object.<string, string>} */
			const jsDoc = {};

			// we can re-use the default transformer from `@cobalt-ui/plugin-js`
			for (const token of tokens) {
				set(transformedTokens, token.id, defaultTransformer(token));
				if (token.$description) {
					jsDoc[token.id] = token.$description;
				}
			}

			let typescriptSource = '';

			Object.keys(transformedTokens).forEach((tokenGroup) => {
				const serialisedJS = serializeJS(transformedTokens[tokenGroup], {
					comments: jsDoc,
				}).trim();

				// create a typescript source string containing the transformed tokens
				typescriptSource += `export const ${tokenGroup} = ${serialisedJS.replace(/;$/, '')} as const;`;
			});

			// now we create a ts program to create the JS and declaration file
			// contents. the program would write to disk by default, so we
			// override that behaviour to capture the output in memory instead.

			// this is where we'll store the output for the JS and declaration files
			/** @type {Object.<string, string>} */
			const output = {};

			// we need to create a fake file name to fool the compiler into
			// thinking it's compiling a real file.
			const fakeFileName = 'fakefile.ts';

			const program = ts.createProgram(
				[fakeFileName],
				{
					declaration: true,
					noEmit: false,
					module: ts.ModuleKind.ESNext,
					target: ts.ScriptTarget.ESNext,
				},
				{
					getSourceFile: (fileName, languageVersion) => {
						// create a 'file' using the value of `typescriptSource`
						// defined above
						return ts.createSourceFile(
							fileName,
							typescriptSource,
							languageVersion,
						);
					},
					writeFile: (name, text) => {
						// capture the output instead of writing it to disk
						output[name] = text;
					},
					// this is stuff the compiler complains about if we don't
					// provide it
					getDefaultLibFileName: () => 'lib.d.ts',
					useCaseSensitiveFileNames: () => false,
					getCanonicalFileName: (filename) => filename,
					getCurrentDirectory: () => '',
					getNewLine: () => '\n',
					fileExists: (fileName) => fileName === fakeFileName,
					readFile: () => undefined,
				},
			);

			program.emit();

			return [
				{
					filename: options.filename,
					contents: header + output[fakeFileName.replace(/\.ts$/, '.js')],
				},
				{
					filename: options.filename.replace(/\.js$/, '.d.ts'),
					contents: header + output[fakeFileName.replace(/\.ts$/, '.d.ts')],
				},
			];
		},
	};
}
